import pandas as pd
import numpy as np
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import StandardScaler
import matplotlib.pyplot as plt
import seaborn as sns

# 1. Missing Value Handling
print("Missing values before handling:")
missing_counts = df.isnull().sum().sort_values(ascending=False)
print(missing_counts)

# Store original columns before dropping
original_columns = set(df.columns)
# Drop columns with >30% missing values
threshold = int(len(df) * 0.7)
df = df.dropna(thresh=threshold, axis=1)
# Determine dropped columns
remaining_columns = set(df.columns)
dropped_columns = list(original_columns - remaining_columns)
print(f"\nDropped columns due to >30% missing values ({len(dropped_columns)}):")
print(dropped_columns)

if df.empty:
    raise ValueError("DataFrame is empty after dropping columns with >30% missing values")

# Separate numerical and categorical columns once
numerical_cols = df.select_dtypes(include=np.number).columns.to_list()
categorical_cols = df.select_dtypes(exclude=np.number).columns.to_list()

# 2. Imputation
if numerical_cols:
    num_imputer = SimpleImputer(strategy='median')
    df[numerical_cols] = num_imputer.fit_transform(df[numerical_cols])
else:
    print("Warning: No numerical columns remaining after preprocessing")

if categorical_cols:
    cat_imputer = SimpleImputer(strategy='most_frequent')
    df[categorical_cols] = cat_imputer.fit_transform(df[categorical_cols])
else:
    print("Warning: No categorical columns remaining after preprocessing")

# 3. Outlier Handling using vectorized approach
def cap_outliers_iqr(series):
    Q1 = series.quantile(0.25)
    Q3 = series.quantile(0.75)
    IQR = Q3 - Q1
    lower = Q1 - 1.5 * IQR
    upper = Q3 + 1.5 * IQR
    return series.clip(lower=lower, upper=upper)

if numerical_cols:
    # Only apply to columns with >5 unique values (likely continuous)
    continuous_cols = [col for col in numerical_cols if df[col].nunique() > 5]
    df[continuous_cols] = df[continuous_cols].apply(cap_outliers_iqr)
else:
    print("No numerical columns available for outlier handling")

# 4. Visualization after outlier handling
if numerical_cols:
    plt.figure(figsize=(12,6))
    sns.boxplot(data=df[numerical_cols[:5]])
    plt.title('Feature Distributions After Outlier Handling')
    plt.xticks(rotation=45)
    plt.show()
else:
    print("Skipping visualization - no numerical columns available")

# 5. Feature Scaling
if numerical_cols:
    scaler = StandardScaler()
    scaled_features = scaler.fit_transform(df[numerical_cols])
    df_scaled = pd.DataFrame(scaled_features, columns=numerical_cols)
else:
    df_scaled = pd.DataFrame()
    print("Warning: No numerical columns available for scaling")

# 6. Final Check
missing_after = df.isnull().sum().sum()
print(f"\nMissing values after handling: {missing_after}")
print(f"Data shape after preprocessing: {df.shape}")
print(f"Scaled data shape: {df_scaled.shape}")
